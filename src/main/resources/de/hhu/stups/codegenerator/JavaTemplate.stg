keywords() ::= <<
abstract, assert, boolean, break, byte, case, catch, char, class, continue, default, do, double, else, enum, extends, final, finally, float, for, if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, try, void, volatile, while, true, false, null, var, const, goto, size
>>


machine(forModelChecking, imports, machine, structs, constants_declarations, includes, enums, sets, declarations, initialization, mainMethod, copyConstructor, operations, addition, getters, transitions, invariant, copy, hash_equal, modelcheck, lambdaFunctions, choicePoints, choicePointsGetters, choicePointOperationFlags, choicePointOperationFlagGetters, choicePointOperationFlagResets, choicePointOperationTriggered, choicePointOperationTriggeredResets, choicePointOperationTriggeredFlags, choicePointOperationApplies) ::= <<
<imports; separator="\n">
<if(forModelChecking)>
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.Future;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import clojure.java.api.Clojure;
import clojure.lang.PersistentHashMap;
import clojure.lang.RT;
import clojure.lang.Var;
<endif>
import java.util.Objects;
import java.util.Arrays;
import de.hhu.stups.btypes.PreconditionOrAssertionViolation;
import de.hhu.stups.btypes.StateNotReachableError;
import de.hhu.stups.btypes.BUtils;


public class <machine> {


    <if(forModelChecking)>
    private static final Var ASSOC;
    private static final Var GET;

    static {
        RT.var("clojure.core", "require").invoke(Clojure.read("clojure.set"));
        ASSOC = RT.var("clojure.core", "assoc");
        GET = RT.var("clojure.core", "get");
    }

    public static enum Type {
        BFS,
        DFS,
        MIXED
    }

    public <machine> parent;
    public Set\<String> dependentGuard = new HashSet\<>();
    public PersistentHashMap guardCache = PersistentHashMap.EMPTY;
    public Set\<String> dependentInvariant = new HashSet\<>();
    public String stateAccessedVia;

    <if(false)>

    // there was no condition, should be fixed in the future

    <choicePoints; separator="\n\n">

    <choicePointOperationTriggeredFlags; separator="\n\n">

    <choicePointOperationFlags; separator="\n\n">

    <endif>

    <endif>

    <structs; separator= "\n\n">

    <constants_declarations; separator="\n">

    <includes; separator="\n">

    <enums; separator="\n\n">

    <sets; separator="\n">

    <declarations; separator="\n">

    <initialization>

    <if(forModelChecking)>

    <copyConstructor>

    <endif>

    <operations; separator="\n\n">

    <getters; separator="\n\n">

    <if(forModelChecking)>

    <transitions; separator="\n\n">

    <invariant; separator="\n\n">

    <copy>

    <if(false)>

    // there was no condition, should be fixed in the future

    <choicePointsGetters; separator="\n\n">

    <choicePointOperationFlagGetters; separator="\n\n">

    <choicePointOperationFlagResets; separator="\n\n">

    <choicePointOperationTriggered; separator="\n\n">

    <choicePointOperationTriggeredResets; separator="\n\n">

    <choicePointOperationApplies; separator="\n\n">

    <endif>

    <hash_equal; separator="\n\n">

    <modelcheck>

    <mainMethod>

    <endif>

    <lambdaFunctions; separator="\n\n">

    <addition>

}

>>

machine_unequal() ::= <<
>>

machine_unequal_predicate() ::= <<
>>

machine_equal(machine, predicates) ::= <<
@Override
public boolean equals(Object o) {
    <machine> o1 = this;
    <machine> o2 = (<machine>) o;
    return <predicates; separator= " && ">;
}
>>

machine_equal_predicate(var) ::= <<
o1.<var>().equals(o2.<var>())
>>

machine_hash(assignments1, assignments2) ::= <<
@Override
public int hashCode() {
    return this._hashCode_1();
}

public int _hashCode_1() {
    int result = 1;
    <assignments1; separator= "\n">
    return result;
}

public int _hashCode_2() {
    int result = 1;
    <assignments2; separator= "\n">
    return result;
}
>>

machine_hash_assignment(primeNumber, var) ::= <<
result = (<primeNumber> * result) ^ ((this.<var>()).hashCode() \<\< 1);
>>

machine_string(variables) ::= <<
@Override
public String toString() {
    <if(variables)>
    return String.join("\n", <variables:{var | "<var>: " + (this.<var>()).toString()}; separator=", ">);
    <else>
    return "";
    <endif>
}
>>


getter(returnType, variable) ::= <<
public <returnType> _get_<variable>() {
    return <variable>;
}
>>

struct(name, declarations, parameters, initializations, functions, equalPredicates, unequalPredicates, fields, values) ::= <<
public static class <name> extends BStruct {
    <declarations; separator="\n">

    public <name>(<parameters; separator=", ">) {
        <initializations; separator="\n">
    }

    <functions; separator="\n\n">

    public BBoolean equal(<name> o) {
        return new BBoolean(<equalPredicates; separator=" && ">);
    }

    public BBoolean unequal(<name> o) {
        return new BBoolean(<unequalPredicates; separator=" || ">);
    }

    public String toString() {
        return "(" + <values; separator=" + \",\" + "> + ")";
    }

    public boolean equals(Object other) {
        if(!(other instanceof <name>)) {
            return false;
        }
        <name> o = (<name>) other;
        return <equalPredicates; separator= " && ">;
    }

    public int hashCode() {
        return Objects.hash(<fields; separator=", ">);
    }
}
>>

record_field_get(type, field) ::= <<
public <type> get_<field>() {
    return this.<field>;
}
>>

record_field_access(record, field) ::= <<
<record>.get_<field>()
>>

record_access_nested(record, field, isNested) ::= <<
<if(!isNested)><record><else><record>.get_<field>()<endif>
>>

record_access_element(expr, arg, val) ::= <<
<expr>.override_<arg>(<val>)
>>

record_field_override(name, field, type, val, parameters) ::= <<
public <name> override_<field>(<type> <field>) {
    return new <name>(<parameters; separator=", ">);
}
>>

record_field_initialization(identifier) ::= <<
this.<identifier> = <identifier>;
>>

record_assignment(identifier) ::= <<
>>

record_field_to_string(identifier) ::= <<
"<identifier> : " + this.<identifier>
>>

record_equal_predicate(field) ::= <<
this.<field> == o.<field>
>>

record_unequal_predicate(field) ::= <<
this.<field> != o.<field>
>>

record(struct, parameters) ::= <<
new <struct>(<parameters; separator=", ">)
>>

initialization(machine, properties, values, body) ::= <<
<if(properties)>
<if(values)>
static {
    <properties; separator="\n">
    <values>
}
<endif>
<endif>

public <machine>() {
    <body>
}
>>

method() ::= <<
>>

operation(returnType, operationName, parameters, locals, body, return) ::= <<
public <returnType> <operationName>(<parameters; separator=", ">) {
    <locals; separator="\n">
    <body>
    <return>
}
>>

return(identifier) ::= <<
return <identifier>;
>>

no_return() ::=<<
>>

set_declaration(identifier, type, enums) ::= <<
private static BSet\<<type>\> <identifier> = <set_enumeration("", type, "", enums, false)>;
>>

set_enumeration(leftType, type, rightType, enums, isRelation) ::= <<
<if(isRelation)>new BRelation\<<leftType>, <rightType>\><else>new BSet\<<type>\><endif>(<enums; separator=", ">)
>>

seq_enumeration(type, elements) ::= <<
new BRelation\<BInteger, <type>\>(<elements; separator=", ">)
>>

iteration_construct_enumeration(otherIterationConstructs, type, identifier, set, body) ::= <<
<otherIterationConstructs>
for(<type> <identifier> : <set>) {
    <body>
}
>>

iteration_construct_assignment(otherIterationConstructs, type, identifier, set, body) ::= <<
<otherIterationConstructs>
for(<type> <identifier> : Arrays.asList(<set>)) {
    <body>
}

>>

iteration_construct_subset(otherIterationConstructs, type, identifier, set, body) ::= <<
<otherIterationConstructs>
for(<type> <identifier> : <set>.pow()) {
    <body>
}
>>

iteration_construct_subsetneq(otherIterationConstructs, type, identifier, set, body) ::= <<
<otherIterationConstructs>
for(<type> <identifier> : <set>.pow().difference(<set>)) {
    <body>
}
>>

let_expression_predicate(type, identifier, hasCondition, conditionalPredicate, body) ::= <<
<type> <identifier> = null;
<if(hasCondition)>
if(<conditionalPredicate>.booleanValue()) {
    <body>
}
<else>
<body>
<endif>
>>

let_expression_predicate_body(otherIterationConstructs, identifier, val) ::= <<
<otherIterationConstructs>
<identifier> = <val>;
>>

set_comprehension(type, identifier, isRelation, leftType, rightType, subType, hasCondition, conditionalPredicate, comprehension) ::= <<
<type> <identifier> = new <if(isRelation)>BRelation\<<leftType>, <rightType>\><else>BSet\<<subType>\><endif>();
<if(hasCondition)>
if(<conditionalPredicate>.booleanValue()) {
    <comprehension>
}
<else>
<comprehension>
<endif>
>>

set_comprehension_predicate(otherIterationConstructs, set, element, emptyPredicate, predicate, isRelation, leftType, rightType, subType) ::= <<
<otherIterationConstructs>
<if(emptyPredicate)>
<set> = <set>.union(new <if(isRelation)>BRelation\<<leftType>, <rightType>\><else>BSet\<<subType>\><endif>(<element>));
<else>
if((<predicate>).booleanValue()) {
    <set> = <set>.union(new <if(isRelation)>BRelation\<<leftType>, <rightType>\><else>BSet\<<subType>\><endif>(<element>));
}
<endif>
>>

lambda(type, identifier, lambda, leftType, rightType, hasCondition, conditionalPredicate) ::= <<
<type> <identifier> = new BRelation\<<leftType>, <rightType>\>();
<if(hasCondition)>
if(<conditionalPredicate>.booleanValue()) {
    <lambda>
}
<else>
<lambda>
<endif>
>>

lambda_expression(otherIterationConstructs, relation, element, expression, emptyPredicate, predicate, leftType, rightType) ::= <<
<otherIterationConstructs>
<if(emptyPredicate)>
<relation> = <relation>.union(new BRelation\<<leftType>, <rightType>\>(new BTuple\<>(<element>, <expression>)));
<else>
if((<predicate>).booleanValue()) {
    <relation> = <relation>.union(new BRelation\<<leftType>, <rightType>\>(new BTuple\<>(<element>, <expression>)));
}
<endif>
>>

lambda_function(function, parameters, returnType, expression) ::= <<
public <returnType> <function>(<parameters; separator=", ">) {
    return <expression>;
}
>>

lambda_function_call(arg1, arg2, fromOtherMachine, otherMachine) ::= <<
<if(fromOtherMachine)><otherMachine>.<endif><arg1>(<arg2; separator=", ">)
>>

quantified_predicate(identifier, forall, hasCondition, conditionalPredicate, predicate) ::= <<
BBoolean <identifier> = new BBoolean(<if(forall)>true<else>false<endif>);
<if(hasCondition)>
if(<conditionalPredicate>.booleanValue()) {
    <predicate>
}
<else>
<predicate>
<endif>
>>

quantified_predicate_evaluation(otherIterationConstructs, identifier, emptyPredicate, predicate, forall) ::= <<
<otherIterationConstructs>
<if(emptyPredicate)>
<identifier> = new BBoolean(<if(forall)>false<else>true<endif>);
break;
<else>
if(<if(forall)>!<endif>(<predicate>).booleanValue()) {
    <identifier> = new BBoolean(<if(forall)>false<else>true<endif>);
    break;
}
<endif>
>>

quantified_expression(identifier, identity, useBigInteger, setType, hasCondition, conditionalPredicate, evaluation, isInteger) ::= <<
<if(isInteger)>BInteger <identifier> = <if(useBigInteger)>new BInteger("<identity>")<else>new BInteger(<identity>)<endif>;<else>BSet\<<setType>\> <identifier> = new BSet\<<setType>\>();<endif>
<if(hasCondition)>
if(<conditionalPredicate>.booleanValue()) {
    <evaluation>
}
<else>
<evaluation>
<endif>
>>

quantified_expression_evaluation(otherIterationConstructs, emptyPredicate, predicate, identifier, operation, expression) ::= <<
<otherIterationConstructs>
<if(emptyPredicate)>
<identifier> = <identifier>.<operation>(<expression>);
<else>
if((<predicate>).booleanValue()) {
    <identifier> = <identifier>.<operation>(<expression>);
}
<endif>
>>

parameter_combination_predicate(otherIterationConstructs, set, element, emptyPredicate, predicate, subType) ::= <<
<otherIterationConstructs>
<if(emptyPredicate)>
<set> = <set>.union(new BSet\<<subType>\>(<element>));
<else>
if((<predicate>).booleanValue()) {
    <set> = <set>.union(new BSet\<<subType>\>(<element>));
}
<endif>
>>

transition(noParameters, noPredicate, identifier, subType, operationName, predicate, hasCondition, conditionalPredicate, combination) ::= <<
public <if(noParameters)>boolean<else>BSet\<<subType>\><endif> _tr_<operationName>() {
    <if(noParameters)>
    <if(noPredicate)>
    return true;
    <else>
    return <predicate>.booleanValue();
    <endif>
    <else>
    BSet\<<subType>\> <identifier> = new BSet\<<subType>\>();
    <if(hasCondition)>
    if(<conditionalPredicate>.booleanValue()) {
        <combination>
    }
    <else>
    <combination>
    <endif>
    return <identifier>;
    <endif>
}
>>

invariant(invariantFunction, iterationConstruct, predicate) ::= <<
public boolean <invariantFunction>() {
    <iterationConstruct; separator="\n">
    return <predicate>.booleanValue();
}
>>

copy_constructor(machine, parameters, assignments) ::= <<
public <machine>(<parameters; separator=", ">) {
    <assignments; separator="\n">
}
>>

copy_assignment(variable) ::= <<
this.<variable> = <variable>;
>>

copy(machine, parameters) ::= <<
public <machine> _copy() {
    return new <machine>(<parameters; separator=", ">);
}
>>

if_expression_predicate(predicate, ifThen, ifElse) ::= <<
(<predicate>.booleanValue() ? <ifThen> : <ifElse>)
>>

enum_call(machine, class, identifier, isCurrentMachine) ::= <<
<if(isCurrentMachine)><class>.<identifier><else><machine>.<class>.<identifier><endif>
>>

set_enum_declaration(name,enums) ::= <<
public enum <name> implements BObject {
    <enums; separator=", \n">;

    public BBoolean equal(<name> o) {
        return new BBoolean(this == o);
    }

    public BBoolean unequal(<name> o) {
        return new BBoolean(this != o);
    }
}
>>

bool() ::= <<
BUtils.BOOL
>>

include_declaration(type, identifier) ::= <<
private <declaration(type, identifier)> = new <type>();
>>

global_declaration(type, identifier) ::= <<
private <declaration(type, identifier)>;
>>

local_declaration(type, identifier) ::= <<
<declaration(type, identifier)> = null;
>>

choice_point_declaration(choicePoint, operation) ::= <<
private int _cp_<operation>_<choicePoint> = 0;

private boolean _flag_cp_<operation>_<choicePoint> = false;
>>

choice_point_getter(choicePoint, operation) ::= <<
public int _get_<operation>_<choicePoint>() {
    return _cp_<operation>_<choicePoint>;
}

public boolean _get_flag_<operation>_<choicePoint>() {
    return _flag_cp_<operation>_<choicePoint>;
}
>>


choice_point_operation_flag_declaration(operation) ::= <<
private boolean _<operation>_flag_cp = false;
>>

choice_point_operation_triggered_declaration(operation) ::= <<
private boolean _<operation>_triggered = false;
>>

choice_point_operation_flag_getter(operation) ::= <<
public boolean _get_<operation>_flag_cp() {
    return _<operation>_flag_cp;
}
>>

choice_point_operation_flag_reset(operation) ::= <<
public void _reset_<operation>_flag_cp() {
    this._<operation>_flag_cp = false;
}
>>

choice_point_operation_triggered(operation) ::= <<
public boolean _get_<operation>_triggered() {
    return _<operation>_triggered;
}
>>

choice_point_operation_triggered_reset(operation) ::= <<
public void _reset_<operation>_triggered() {
    this._<operation>_triggered = false;
}
>>

choice_point_operation_apply(machine, operation, applyChoicePoints, applyChoicePointFlag) ::= <<
public void _apply_<operation>_cp(<machine> machine) {
    <applyChoicePoints; separator="\n">
    <applyChoicePointFlag>
}
>>

choice_point_operation_apply_choice_point(operation, choicePoint) ::=<<
this._cp_<operation>_<choicePoint> = machine._cp_<operation>_<choicePoint>;
>>

choice_point_operation_apply_choice_point_flag(operation) ::= <<
this._<operation>_flag_cp = machine._<operation>_flag_cp;
>>

constant_declaration(type, identifier) ::= <<
private static <type> <identifier>;
>>

constant_initialization(iterationConstruct, identifier, val) ::= <<
<iterationConstruct; separator="\n">
<identifier> = <val>;
>>

values(assignments) ::= <<
<assignments; separator="\n">
>>

declaration(type, identifier) ::= <<
<type> <identifier>
>>

parameter(type, identifier) ::= <<
<type> <identifier>
>>

parallel(loads, others) ::=<<
<loads; separator="\n">
<others; separator="\n">
>>

parallel_load(type, identifier) ::= <<
<type> _ld_<identifier> = <identifier>;
>>

assignment(iterationConstruct, identifier, modified_identifier, val, isIdentifierLhs, isRecordAccessLhs, arg, leftType, rightType) ::= <<
<iterationConstruct; separator="\n">
<if(isIdentifierLhs)><identifier> = <val>;<elseif(isRecordAccessLhs)><identifier> = <modified_identifier>.override_<arg>(<val>);<else><identifier> = <modified_identifier>.override(new BRelation\<<leftType>, <rightType>\>(new BTuple\<<leftType>, <rightType>\>(<arg>,<val>)));<endif>
>>

function_call_range_element(expr, leftType, rightType, arg, val) ::= <<
<expr>.override(new BRelation\<<leftType>, <rightType>\>(new BTuple\<<leftType>, <rightType>\>(<arg>,<val>)))
>>

function_call_nested(expr, arg, isNested) ::= <<
<if(!isNested)><expr><else><expr>.functionCall(<arg>)<endif>
>>

assignments(assignments) ::= <<
<assignments; separator="\n">
>>

nondeterminism(iterationConstruct, identifier, modified_identifier, set, isIdentifierLhs, isRecordAccessLhs, arg, leftType, rightType, forModelChecking, choicePoint, operation, isLastChoicePoint, usePreviousChoicePoint, previousChoicePoint) ::= <<
<iterationConstruct; separator="\n">
<if(forModelChecking)>
int _ctr_cp_<operation>_<choicePoint> = _cp_<operation>_<choicePoint>;
boolean _triggered_cp_<operation>_<choicePoint> = false;
<if(isIdentifierLhs)><identifier> = <set>.nondeterminism(_ctr_cp_<operation>_<choicePoint>);<elseif(isRecordAccessLhs)><identifier> = <modified_identifier>.override_<arg>(<set>.nondeterminism(_ctr_cp_<operation>_<choicePoint>));<else><identifier> = <modified_identifier>.override(new BRelation\<<leftType>, <rightType>\>(new BTuple\<>(<arg>,<set>.nondeterminism(_ctr_cp_<operation>_<choicePoint>)));<endif>
<if(isLastChoicePoint)>
_cp_<operation>_<choicePoint>++;
<endif>
if(<identifier> != null) {
    _triggered_cp_<operation>_<choicePoint> = true;
}
if(!_triggered_cp_<operation>_<choicePoint>) {
    _cp_<operation>_<choicePoint> = 0;
    <if(usePreviousChoicePoint)>
    _cp_<operation>_<previousChoicePoint>++;
    <else>
    _<operation>_flag_cp = true;
    <endif>
    _<operation>_triggered = false;
    return;
} else {
    _<operation>_triggered = true;
}
<else>
<if(isIdentifierLhs)><identifier> = <set>.nondeterminism();<elseif(isRecordAccessLhs)><identifier> = <modified_identifier>.override_<arg>(<set>.nondeterminism());<else><identifier> = <modified_identifier>.override(new BRelation\<<leftType>, <rightType>\>(new BTuple\<>(<arg>,<set>.nondeterminism()));<endif>
<endif>
>>

void() ::= <<
void
>>

type(type, fromOtherMachine, otherMachine) ::= <<
<if(fromOtherMachine)><otherMachine>.<endif><type>
>>

tuple_type(leftType, rightType) ::= <<
BTuple\<<leftType>, <rightType>\>
>>

set_type(type) ::=<<
BSet\<<type>\>
>>

relation_type(leftType, rightType) ::=<<
BRelation\<<leftType>, <rightType>\>
>>

import_type(type) ::= <<
import de.hhu.stups.btypes.<type>;
>>

import_machine(machine) ::= <<
import de.hhu.stups.btypes.<machine>;
>>

mc_info_type(isSet, machine, type) ::= <<
<if(isSet)><machine>$<type><else>de.hhu.stups.btypes.<type><endif>
>>


interval(arg1, arg2) ::= <<
BSet.interval(<arg1>, <arg2>)
>>

projection(arg1, arg2, isProjection1) ::= <<
BRelation.<if(isProjection1)>projection1<else>projection2<endif>(<arg1>,<arg2>)
>>

projection_tuple(arg, isProjection1) ::= <<
<arg>.<if(isProjection1)>projection1<else>projection2<endif>()
>>

identity(arg) ::= <<
BRelation.identity(<arg>)
>>

cartesian_product(arg1, arg2) ::= <<
BRelation.cartesianProduct(<arg1>, <arg2>)
>>

tuple_create(arg1, arg2) ::= <<
new BTuple\<>(<arg1>, <arg2>)
>>

binary(arg1,operator,arg2) ::= <<
<arg1>.<operator>(<arg2>)
>>

or(arg1, arg2) ::= <<
new BBoolean(<arg1>.booleanValue() || <arg2>.booleanValue())
>>

and(arg1, arg2) ::= <<
new BBoolean(<arg1>.booleanValue() && <arg2>.booleanValue())
>>

implies(arg1, arg2) ::= <<
new BBoolean(!<arg1>.booleanValue() || <arg2>.booleanValue())
>>

equivalent(arg1, arg2) ::= <<
new BBoolean((!<arg1>.booleanValue() || <arg2>.booleanValue()) && (!<arg2>.booleanValue() || <arg1>.booleanValue()))
>>

unary(operator, obj, args) ::= <<
<obj>.<operator>(<args; separator=", ">)
>>

pre_assert(isModelChecking, isTopLevel, iterationConstruct, predicate, then) ::= <<
<if(isModelChecking && !isTopLevel)>
<iterationConstruct; separator="\n">
if((<predicate>).booleanValue()) {
    <then>
} else {
    throw new PreconditionOrAssertionViolation("Precondition or Assertion Error occured.");
}
<else>
<then>
<endif>
>>

select(isModelChecking, isTopLevel, iterationConstruct, predicate, then) ::= <<
<if(isModelChecking && isTopLevel)>
<then>
<else>
<iterationConstruct; separator="\n">
if((<predicate>).booleanValue()) {
    <then>
} else {
    throw new StateNotReachableError("State is not reachable.");
}
<endif>
>>

if(iterationConstruct, predicate, then, else1, forModelChecking, operation, choicePoint, usePreviousChoicePoint, previousChoicePoint) ::= <<
<iterationConstruct; separator="\n">
<if(false)>
// condition was: \<if(false)>
int index = _cp_<operation>_<choicePoint>;
int _ctr_cp_<operation>_<choicePoint> = -1;
boolean _triggered_cp_<operation>_<choicePoint> = false;
<endif>

if((<predicate>).booleanValue()) {
    <then>
} <else1; separator=" ">
<if(false)>
// condition was: \<if(false)>
if(!_triggered_cp_<operation>_<choicePoint>) {
    _cp_<operation>_<choicePoint> = 0;
    <if(usePreviousChoicePoint)>
    _cp_<operation>_<previousChoicePoint>++;
    <else>
    _<operation>_flag_cp = true;
    <endif>
    _<operation>_triggered = false;
    return;
} else {
    _<operation>_triggered = true;
}
<endif>
>>

elseif(predicate, then) ::= <<
else if((<predicate>).booleanValue()) {
    <then>
}
>>

else(then) ::= <<
else {
    <then>
}
>>

choice(len, then, choice1, forModelChecking, choicePoint, operation, isLastChoicePoint, usePreviousChoicePoint, previousChoicePoint) ::= <<
<if(forModelChecking)>
int index = _cp_<operation>_<choicePoint>;
int _ctr_cp_<operation>_<choicePoint> = -1;
boolean _triggered_cp_<operation>_<choicePoint> = false;
<else>
int index = (int) Math.floor(Math.random() * <len>);
<endif>
if(index == 0) {
    <if(forModelChecking)>
    <if(isLastChoicePoint)>
    _cp_<operation>_<choicePoint>++;
    <endif>
    _triggered_cp_<operation>_<choicePoint> = true;
    <then>
    <else>
    <then>
    <endif>
} <choice1; separator=" ">
<if(forModelChecking)>
if(!_triggered_cp_<operation>_<choicePoint>) {
    _cp_<operation>_<choicePoint> = 0;
    <if(usePreviousChoicePoint)>
    _cp_<operation>_<previousChoicePoint>++;
    <else>
    _<operation>_flag_cp = true;
    <endif>
    _<operation>_triggered = false;
    return;
} else {
    _<operation>_triggered = true;
}
<endif>
>>


choice1(counter, then, forModelChecking, choicePoint, operation, isLastChoicePoint) ::= <<
else if(index == <counter>) {
    <if(forModelChecking)>
    <if(isLastChoicePoint)>
    _cp_<operation>_<choicePoint>++;
    <endif>
    _triggered_cp_<operation>_<choicePoint> = true;
    <then>
    <else>
    <then>
    <endif>
}
>>

choice2(then, counter, forModelChecking, choicePoint, operation, isLastChoicePoint) ::= <<
<if(forModelChecking)>
else if(index == <counter>) {
    <if(isLastChoicePoint)>
    _cp_<operation>_<choicePoint>++;
    <endif>
    _triggered_cp_<operation>_<choicePoint> = true;
    <then>
}
<else>
else {
    <then>
}
<endif>
>>

any(body, forModelChecking, usePreviousChoicePoint, previousChoicePoint, choicePoint, operation) ::= <<
<if(forModelChecking)>
int _ctr_cp_<operation>_<choicePoint> = -1;
boolean _triggered_cp_<operation>_<choicePoint> = false;
<body>
if(!_triggered_cp_<operation>_<choicePoint>) {
    _cp_<operation>_<choicePoint> = 0;
    <if(usePreviousChoicePoint)>
    _cp_<operation>_<previousChoicePoint>++;
    <else>
    _<operation>_flag_cp = true;
    <endif>
    _<operation>_triggered = false;
    return;
} else {
    _<operation>_triggered = true;
}
<else>
<body>
<endif>
>>

any_body(otherIterationConstructs, emptyPredicate, predicate, body, forModelChecking, choicePoint, operation, isLastChoicePoint) ::= <<
<otherIterationConstructs>
<if(emptyPredicate)>
<if(forModelChecking)>
if(_triggered_cp_<operation>_<choicePoint>) {
    continue;
}
_ctr_cp_<operation>_<choicePoint>++;
if(_ctr_cp_<operation>_<choicePoint> == _cp_<operation>_<choicePoint>) {
    _triggered_cp_<operation>_<choicePoint> = true;
    <body>
   <if(isLastChoicePoint)>
   _cp_<operation>_<choicePoint>++;
   <endif>
    break;
}
<else>
<body>
break;
<endif>
<else>
<if(forModelChecking)>
if(_triggered_cp_<operation>_<choicePoint>) {
    continue;
}
_ctr_cp_<operation>_<choicePoint>++;
if(_ctr_cp_<operation>_<choicePoint> == _cp_<operation>_<choicePoint>) {
    _triggered_cp_<operation>_<choicePoint> = true;
    <if(isLastChoicePoint)>
    _cp_<operation>_<choicePoint>++;
    <endif>
    if((<predicate>).booleanValue()) {
        <body>
        break;
    }
}
<else>
if((<predicate>).booleanValue()) {
    <body>
    break;
}
<endif>
<endif>
>>

becomes_such_that(loads, body, forModelChecking, operation, choicePoint, usePreviousChoicePoint, previousChoicePoint) ::= <<
<if(forModelChecking)>
int _ctr_cp_<operation>_<choicePoint> = -1;
boolean _triggered_cp_<operation>_<choicePoint> = false;
<loads; separator="\n">
<body>
if(!_triggered_cp_<operation>_<choicePoint>) {
    _cp_<operation>_<choicePoint> = 0;
    <if(usePreviousChoicePoint)>
    _cp_<operation>_<previousChoicePoint>++;
    <else>
    _<operation>_flag_cp = true;
    <endif>
    _<operation>_triggered = false;
    return;
} else {
    _<operation>_triggered = true;
}
<else>
<loads; separator="\n">
<body>
<endif>
>>

becomes_such_that_body(otherIterationConstructs, emptyPredicate, predicate, stores, forModelChecking, choicePoint, operation, isLastChoicePoint) ::= <<
<otherIterationConstructs>
<if(emptyPredicate)>
<if(forModelChecking)>
if(_triggered_cp_<operation>_<choicePoint>) {
    continue;
}
_ctr_cp_<operation>_<choicePoint>++;
if(_ctr_cp_<operation>_<choicePoint> == _cp_<operation>_<choicePoint>) {
    _triggered_cp_<operation>_<choicePoint> = true;
    <stores>
    <if(isLastChoicePoint)>
    _cp_<operation>_<choicePoint>++;
    <endif>
    break;
}
<else>
<stores>
break;
<endif>
<else>
<if(forModelChecking)>
if(_triggered_cp_<operation>_<choicePoint>) {
    continue;
}
_ctr_cp_<operation>_<choicePoint>++;
if(_ctr_cp_<operation>_<choicePoint> == _cp_<operation>_<choicePoint>) {
    _triggered_cp_<operation>_<choicePoint> = true;
    <if(isLastChoicePoint)>
    _cp_<operation>_<choicePoint>++;
    <endif>
    if((<predicate>).booleanValue()) {
        <stores>
        break;
    }
}
<else>
if((<predicate>).booleanValue()) {
    <stores>
    break;
}
<endif>
<endif>
>>

becomes_such_that_load(type, lhs, rhs) ::= <<
<type> <lhs> = <rhs>;
>>

becomes_such_that_store(lhs, rhs) ::= <<
<lhs> = <rhs>;
>>

while(iterationConstruct1, iterationConstruct2, predicate, then) ::= <<
<iterationConstruct1; separator="\n">
while((<predicate>).booleanValue()) {
    <then>
    <iterationConstruct2; separator="\n">
}
>>

var(locals, body) ::=<<
<locals; separator="\n">
<body>
>>

boolean_val(val) ::= <<
<if(val)>new BBoolean(true)<else>new BBoolean(false)<endif>
>>

identifier(identifier, rhsOnLhs, fromOtherMachine, otherMachine) ::= <<
<if(fromOtherMachine)><otherMachine>._get_<identifier>()<else><if(rhsOnLhs)>_ld_<identifier><else><identifier><endif><endif>
>>

number(number, useBigInteger) ::= <<
<if(useBigInteger)>new BInteger("<number>")<else>new BInteger(<number>)<endif>
>>

infinite_predicate(arg, operator) ::= <<
<arg>.<operator>()
>>

relation_predicate(predicates, checkElementOf) ::= <<
<if(checkElementOf)><predicates><else><predicates>.not()<endif>
>>

relation_check_domain(arg, domain) ::= <<
<arg>.checkDomain(<domain>)
>>

relation_check_range(arg, range) ::= <<
<arg>.checkRange(<range>)
>>

relation_total_partial(arg, operator, domain) ::= <<
<arg>.<operator>(<domain>)
>>

relation_function(arg, operator) ::= <<
<arg>.<operator>()
>>

relation_surjection(arg, range) ::= <<
<arg>.isSurjection(<range>)
>>

relation_injection(arg) ::= <<
<arg>.isInjection()
>>

relation_bijection(arg, range) ::=<<
<arg>.isBijection(<range>)
>>

string(string) ::= <<
new BString(<string>)
>>

operation_call_with_assignment_many_parameters(struct, var, machine, machineInstance, function, args, this, assignments) ::= <<
<machine>.<struct> <var> = <operation_call_without_assignment(machineInstance, function, args, this)>
<assignments; separator="\n">
>>

operation_call_assignment(var, record, field) ::= <<
<var> = <record>.get_<field>();
>>

operation_call_with_assignment_one_parameter(var, machineInstance, function, args, this) ::= <<
<var> = <operation_call_without_assignment(machineInstance, function, args, this)>
>>

operation_call_without_assignment(machineInstance, function, args, this) ::= <<
<if(this)>this.<else>this.<machineInstance>.<endif><function>(<args; separator=",">);
>>

skip() ::= <<
>>

enum_import() ::= <<
>>

modelchecker(machine, addCachedInfos, main, nextStates, invariantViolated, printResult) ::= <<

private static class ModelChecker {
    private final Type type;
    private final int threads;
    private final boolean isCaching;
    private final boolean isDebug;

    private final LinkedList\<<machine>\> unvisitedStates = new LinkedList\<>();
    private final Set\<<machine>\> states = new HashSet\<>();
    private AtomicInteger transitions = new AtomicInteger(0);
    private ThreadPoolExecutor threadPool;
    private Object waitLock = new Object();

    private AtomicBoolean invariantViolated = new AtomicBoolean(false);
    private AtomicBoolean deadlockDetected = new AtomicBoolean(false);
    private <machine> counterExampleState = null;

    private final Map\<String, Set\<String>\> invariantDependency = new HashMap\<>();
    private final Map\<String, Set\<String>\> guardDependency = new HashMap\<>();

    public ModelChecker(final Type type, final int threads, final boolean isCaching, final boolean isDebug) {
        this.type = type;
        this.threads = threads;
        this.isCaching = isCaching;
        this.isDebug = isDebug;
    }

    <main>

    private <machine> next() {
        synchronized(this.unvisitedStates) {
            return switch(type) {
                case BFS -> this.unvisitedStates.removeFirst();
                case DFS -> this.unvisitedStates.removeLast();
                case MIXED -> this.unvisitedStates.size() % 2 == 0 ? this.unvisitedStates.removeFirst() : this.unvisitedStates.removeLast();
            };
        }
    }

    <nextStates>

    <invariantViolated>

    <addCachedInfos>

    <printResult>
}

>>

model_check_next_states(machine, transitionsWithCaching, transitionsWithoutCaching) ::= <<
@SuppressWarnings("unchecked")
private Set\<<machine>\> generateNextStates(final <machine> state) {
    Set\<<machine>\> result = new HashSet\<>();
    if(isCaching) {
        PersistentHashMap parentsGuard = state.guardCache;
        PersistentHashMap newCache = parentsGuard == null ? PersistentHashMap.EMPTY : parentsGuard;
        Object cachedValue = null;
        boolean dependentGuardsBoolean = true;
        <transitionsWithCaching>
        state.guardCache = newCache;
    } else {
        <transitionsWithoutCaching>
    }
    return result;
}
>>

model_check_transition(hasParameters, tupleType, transitionIdentifier, evalTransitions, execTransitions, isCaching) ::= <<
<if(hasParameters)>
<if(isCaching)>
BSet\<<tupleType>\> <transitionIdentifier>;
if(!state.dependentGuard.isEmpty()) {
    cachedValue = GET.invoke(parentsGuard, "<evalTransitions>");
    dependentGuardsBoolean = state.dependentGuard.contains("<evalTransitions>");
}

if(state.dependentGuard.isEmpty() || dependentGuardsBoolean || parentsGuard == null || cachedValue == null) {
    <transitionIdentifier> = state.<evalTransitions>();
} else {
    <transitionIdentifier> = (BSet\<<tupleType>\>) cachedValue;
}
newCache = (PersistentHashMap) ASSOC.invoke(newCache, "<evalTransitions>", <transitionIdentifier>);
for(<tupleType> param : <transitionIdentifier>) {
    <execTransitions>
}
<else>
BSet\<<tupleType>\> <transitionIdentifier> = state.<evalTransitions>();
for(<tupleType> param : <transitionIdentifier>) {
    <execTransitions>
}
<endif>
<else>
<if(isCaching)>
boolean <transitionIdentifier>;
if(!state.dependentGuard.isEmpty()) {
    cachedValue = GET.invoke(parentsGuard, "<evalTransitions>");
    dependentGuardsBoolean = state.dependentGuard.contains("<evalTransitions>");
}

if(state.dependentGuard.isEmpty() || dependentGuardsBoolean || parentsGuard == null || cachedValue == null) {
    <transitionIdentifier> = state.<evalTransitions>();
} else {
    <transitionIdentifier> = (boolean) cachedValue;
}

newCache = (PersistentHashMap) ASSOC.invoke(newCache, "<evalTransitions>", <transitionIdentifier>);
if(<transitionIdentifier>) {
    <execTransitions>
}
<else>
if(state.<evalTransitions>()) {
    <execTransitions>
}
<endif>
<endif>
>>

model_check_add_cached_infos(machine) ::= <<
private void addCachedInfos(final String operation, final <machine> state, final <machine> copiedState) {
    if(isCaching) {
        copiedState.dependentInvariant = invariantDependency.get(operation);
        copiedState.dependentGuard = guardDependency.get(operation);
    }
    copiedState.stateAccessedVia = operation;
}
>>

model_check_transition_body(machine, operation, hasParameters, isNondeterministic, readParameters, parameters, caching) ::= <<
<if(hasParameters)>
<readParameters>
<endif>
<if(isNondeterministic)>
<machine> currentState = state._copy();
Set\<<machine>\> newStatesForNondeterministic = new HashSet\<>();
while(!currentState._get_calculate_flag_cp()) {
    <machine> copiedState = state._copy();
    copiedState._apply_<operation>_cp(currentState);
    copiedState.<operation>(<parameters; separator=", ">);
    copiedState.parent = state;
    if(copiedState._get_<operation>_triggered()) {
        addCachedInfos("<operation>", state, copiedState);
        if(!newStatesForNondeterministic.contains(copiedState)) {
            transitions.getAndIncrement();
        }
        result.add(copiedState);
        newStatesForNondeterministic.add(copiedState);
    }
    currentState._apply_<operation>_cp(copiedState);
    copiedState._reset_<operation>_triggered();
    copiedState._reset_<operation>_flag_cp();
}
<else>
<machine> copiedState = state._copy();
copiedState.<operation>(<parameters; separator=", ">);
copiedState.parent = state;
addCachedInfos("<operation>", state, copiedState);
result.add(copiedState);
transitions.getAndIncrement();
<endif>
>>

model_check_transition_param_assignment(type, param, val, isLhs, oneParameter) ::= <<
<if(isLhs)>
<type> <param> = <val>.projection1();
<else>
<if(oneParameter)>
<type> <param> = <val>;
<else>
<type> <param> = <val>.projection2();
<endif>
<endif>
>>

model_check_invariants(machine, invariantViolated, invariants) ::= <<
private boolean invariantViolated(final <machine> state) {
    if(isCaching) {
        <invariantViolated; separator="\n">
        return false;
    }
    return !(<invariants:{inv | state.<inv>()}; separator=" && ">);
}
>>

model_check_invariant(invariant) ::= <<
if(state.dependentInvariant.contains("<invariant>")) {
    if(!state.<invariant>()) {
        return true;
    }
}
>>

model_check_evaluate_state(machine, variables) ::= <<
>>

model_check_evaluate_variable(getter) ::= <<
state.put("<getter>", machine.<getter>());
>>

model_check_print(machine) ::= <<
private void printResult(final int states, final int transitions) {
    if(invariantViolated.get() || deadlockDetected.get()) {
        if(deadlockDetected.get()) {
            System.out.println("DEADLOCK DETECTED");
        } else {
            System.out.println("INVARIANT VIOLATED");
        }

        System.out.println("COUNTER EXAMPLE TRACE: ");
        StringBuilder sb = new StringBuilder();
        while(counterExampleState != null) {
            sb.insert(0, counterExampleState);
            sb.insert(0, "\n");
            if(counterExampleState.stateAccessedVia != null) {
                sb.insert(0, counterExampleState.stateAccessedVia);
            }
            sb.insert(0, "\n\n");
            counterExampleState = counterExampleState.parent;
        }
        System.out.println(sb);
    } else {
        System.out.println("MODEL CHECKING SUCCESSFUL");
    }

    System.out.println("Number of States: " + states);
    System.out.println("Number of Transitions: " + transitions);
}
>>

model_check_init_static(map, keyy, entries) ::= <<
<map>.put("<keyy>", new HashSet\<>(Arrays.asList(<entries:{entry | "<entry>"}; separator=", ">)));
>>

model_check_main(machine, invariants, invariantDependency, guardDependency) ::= <<
public void modelCheck() {
    if (isDebug) {
        System.out.println("Starting Modelchecking, STRATEGY=" + type + ", THREADS=" + threads + ", CACHING=" + isCaching);
    }

    if (threads \<= 1) {
        modelCheckSingleThreaded();
    } else {
        this.threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(threads-1);
        modelCheckMultiThreaded();
    }
}

private void modelCheckSingleThreaded() {
    <machine> machine = new <machine>();
    states.add(machine); // TODO: store hashes instead of machine?
    unvisitedStates.add(machine);

    if(isCaching) {
        initCache(machine);
    }

    while(!unvisitedStates.isEmpty()) {
        <machine> state = next();

        Set\<<machine>\> nextStates = generateNextStates(state);

        nextStates.forEach(nextState -> {
            if(!states.contains(nextState)) {
                states.add(nextState);
                unvisitedStates.add(nextState);
                if(states.size() % 50000 == 0 && isDebug) {
                    System.out.println("VISITED STATES: " + states.size());
                    System.out.println("EVALUATED TRANSITIONS: " + transitions.get());
                    System.out.println("-------------------");
                }
            }
        });

        if(invariantViolated(state)) {
            invariantViolated.set(true);
            counterExampleState = state;
            break;
        }

        if(nextStates.isEmpty()) {
            deadlockDetected.set(true);
            counterExampleState = state;
            break;
        }

    }
    printResult(states.size(), transitions.get());
}

private void modelCheckMultiThreaded() {
    <machine> machine = new <machine>();
    states.add(machine);
    unvisitedStates.add(machine);

    AtomicBoolean stopThreads = new AtomicBoolean(false);
    AtomicInteger possibleQueueChanges = new AtomicInteger(0);

    if(isCaching) {
        initCache(machine);
    }

    while(!unvisitedStates.isEmpty() && !stopThreads.get()) {
        possibleQueueChanges.incrementAndGet();
        <machine> state = next();
        Runnable task = () -> {
            Set\<<machine>\> nextStates = generateNextStates(state);

            nextStates.forEach(nextState -> {
                synchronized (states) {
                    if(!states.contains(nextState)) {
                        states.add(nextState);
                        synchronized (unvisitedStates) {
                            unvisitedStates.add(nextState);
                        }
                        if(states.size() % 50000 == 0 && isDebug) {
                            System.out.println("VISITED STATES: " + states.size());
                            System.out.println("EVALUATED TRANSITIONS: " + transitions.get());
                            System.out.println("-------------------");
                        }
                    }
                }
            });

            synchronized (unvisitedStates) {
                int running = possibleQueueChanges.decrementAndGet();
                if (!unvisitedStates.isEmpty() || running == 0) {
                    synchronized (waitLock) {
                        waitLock.notify();
                    }
                }
            }

            if(invariantViolated(state)) {
                invariantViolated.set(true);
                counterExampleState = state;
                stopThreads.set(true);
            }

            if(nextStates.isEmpty()) {
                deadlockDetected.set(true);
                counterExampleState = state;
                stopThreads.set(true);
            }

        };

        threadPool.submit(task);
        synchronized(waitLock) {
            if (unvisitedStates.isEmpty() && possibleQueueChanges.get() > 0) {
                try {
                    waitLock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

    }
    threadPool.shutdown();
    try {
        threadPool.awaitTermination(5, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    printResult(states.size(), transitions.get());
}

private void initCache(final <machine> machine) {
    <invariantDependency; separator="\n">
    <guardDependency; separator="\n">
}
>>

model_check_main_method(machine) ::= <<
public static void main(String[] args) {
    if(args.length > 4) {
        System.out.println("Expecting 3 command-line arguments: STRATEGY THREADS CACHING DEBUG");
        return;
    }
    Type type = Type.MIXED;
    int threads = 0;
    boolean isCaching = false;
    boolean isDebug = false;
    
    if(args.length > 0) { 
        if("mixed".equals(args[0])) {
            type = Type.MIXED;
        } else if("bf".equals(args[0])) {
            type = Type.BFS;
        } else if ("df".equals(args[0])) {
            type = Type.DFS;
        } else {
            System.out.println("Value for command-line argument STRATEGY is wrong.");
            System.out.println("Expecting mixed, bf or df.");
            return;
        }
    }
    if(args.length > 1) { 
        try {
            threads = Integer.parseInt(args[1]);
        } catch(NumberFormatException e) {
            System.out.println("Value for command-line argument THREADS is not a number.");
            return;
        }
        if(threads \<= 0) {
            System.out.println("Value for command-line argument THREADS must be positive.");
            return;
        }
    }
    if(args.length > 2) { 
        try {
            isCaching = Boolean.parseBoolean(args[2]);
        } catch(Exception e) {
            System.out.println("Value for command-line argument CACHING is not a boolean.");
            return;
        }
    }
    if(args.length > 3) { 
        try {
            isDebug = Boolean.parseBoolean(args[3]);
        } catch(Exception e) {
            System.out.println("Value for command-line argument DEBUG is not a boolean.");
            return;
        }
    }

    ModelChecker modelchecker = new ModelChecker(type, threads, isCaching, isDebug);
    modelchecker.modelCheck();
}
>>

record_private_variable_prefix() ::= <<
>>



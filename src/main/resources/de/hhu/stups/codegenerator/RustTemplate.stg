keywords() ::= <<
as, break, const, continue, crate, else, enum, extern, false, fn, for, if, impl, in, let, loop, match, mod, move, mut, pub, ref, return, self, Self, static, struct, super, trait, true, type, unsafe, use, where, while, async, await, dyn, abstract, become, box, do, final, macro, override, priv, typeof, unsized, virtual, yield, try, union, dyn, min, max, new
>>


machine(imports, includedMachines, machine, structs, constants_declarations, includes, enums, sets, declarations, initialization, operations, addition, useBigInteger, getters, lambdaFunctions, forModelChecking, transitions, invariant, copy, modelcheck) ::= <<
#![ allow( dead_code, unused_imports, unused_mut, non_snake_case, non_camel_case_types, unused_assignments ) ]
<if(forModelChecking)>
use std::env;
use std::sync::atomic::{AtomicI32, AtomicI64, AtomicBool, Ordering};
use std::sync::{Arc, Mutex};
use std::collections::{HashMap, HashSet, LinkedList};
use im::HashMap as PersistentHashMap;
<endif>
use std::fmt;
use rand::{thread_rng, Rng};
use btypes::butils;
<imports; separator="\n">
<includedMachines; separator="\n">

<if(forModelChecking)>
#[derive(Copy)]
pub enum MC_TYPE { BFS, DFS, MIXED }
<endif>

<structs; separator="\n\n">

<enums; separator="\n\n">

#[derive(Clone, Default, Debug)]
pub struct <machine> {
    <if(declarations)><declarations; separator="\n"><endif>
    <if(includes)><includes; separator="\n"><endif>
    <if(constants_declarations)><constants_declarations; separator="\n"><endif>
    <sets; separator="\n">
}

impl <machine> {
    <initialization>
    <if(getters)><\n><getters; separator="\n\n"><endif>
    <if(operations)><\n><operations; separator="\n\n">
    <endif>

<if(forModelChecking)>

    <transitions; separator="\n\n">

    <invariant; separator="\n\n">

    <copy>

    <modelcheck>

<endif>
}

<lambdaFunctions; separator="\n\n">
<addition>
>>

import_type(type, useBigInteger) ::= <<
use btypes::<type; format="lower">::<type>;
>>

initialization(machine, properties, values, body, sets, set_initializations, includesInitialization) ::= <<

pub fn new() -> <machine> {
<if(values)>    //values: '<values>'<endif>
    let mut m: <machine> = Default::default();
    m.init();
    return m;
}
fn init(&mut self) {
    <properties; separator="\n">
    <sets; separator="\n">
    <set_initializations; separator="\n">
    <body>
    <includesInitialization; separator="\n">
}
>>

assignment(leftType, rightType, rightTypeIsCollection, iterationConstruct, identifier, modified_identifier, val, isIdentifierLhs, isRecordAccessLhs, arg, lhsIsLocal, lhsIsParam, useBigInteger) ::= <<
<iterationConstruct; separator="\n">
<if(isIdentifierLhs)><identifier> = <if(lhsIsLocal && !lhsIsParam)>Option::Some(<endif><val><if(rightTypeIsCollection || useBigInteger)>.clone()<endif><if(lhsIsLocal && !lhsIsParam)>)<endif><if(rightTypeIsCollection)>.clone()<endif>;<elseif(isRecordAccessLhs)><identifier> = <modified_identifier>.override_<arg>(<val>);<else><identifier> = <modified_identifier>._override(&BRelation::\<<leftType>, <rightType>\>::new(vec![BTuple::new(<arg>,<val>)]));<endif>
>>

identifier(machine, identifier, isReturn, isPrivate, isLocal, isParam, isAssigned, rhsOnLhs, fromOtherMachine, otherMachine, isConstant, isDefiningLdVariable, useBigInteger) ::= <<
<if(fromOtherMachine)>self.<otherMachine>.get_<identifier>()<elseif(isLocal && !isParam && !isAssigned && !isConstant)><identifier><if(useBigInteger)>.as_ref()<endif>.unwrap()<else><if(rhsOnLhs)>_ld_<elseif(isPrivate && !isDefiningLdVariable)>self.<elseif(isConstant)>self.<endif><identifier><endif>
>>

getter(returnType, isConstant, machine, variable) ::= <<
pub fn get_<variable>(&self) -> <returnType> {
    return self.<variable>.clone();
}
>>

operation(returnType, operationName, parameters, locals, body, return) ::= <<
pub fn <operationName>(&mut self<if(parameters)>, <endif><parameters; separator=", ">) -> <returnType> {
    <locals; separator="|">
    <body>
    <return>
}
>>

parameter(type, identifier) ::= <<
mut <identifier>: <type>
>>

return(identifier,isLocal) ::= <<
return <identifier><if(isLocal)>.unwrap()<endif>;
>>

no_return() ::=<<
>>

void() ::= <<
()
>>

local_declaration(type, identifier) ::= <<
<declaration(type, identifier)>
>>

declaration(type, identifier) ::= <<
let mut <identifier>: Option\<<type>\> = Option::None;
>>

number(number, useBigInteger) ::= <<
BInteger::new(<if(useBigInteger)>b"<number>"<else><number><endif>)
>>

struct(name, declarations, parameters, initializations, functions, assignments, equalPredicates, unequalPredicates, values, fields) ::= <<
#[derive(Default, Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct <name> {
    <if(declarations)><declarations; separator="\n"><endif>
}

impl fmt::Display for <name> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "<values:{v | <v>: {\}}; separator=",">", <values:{v | self.<v>}; separator=" ,">)
    }
}

impl BObject for <name> {}
impl BStruct for <name> {}

impl <name> {
    pub fn new(<parameters; separator=", ">) -> <name> {
        let mut m: <name> = Default::default();
        <initializations>
        return m;
    }

    <functions; separator="\n\n">

    pub fn equal(&self, other: &<name>) -> BBoolean {
        return BBoolean::new(<equalPredicates; separator=" && ">);
    }

    pub fn unequal(&self, other: &<name>) -> BBoolean {
        return BBoolean::new(<unequalPredicates; separator=" || ">);
    }

    <if(assignments)><assignments><endif>
}
>>

record_field_initialization(identifier) ::= <<
m.<identifier> = <identifier>;
>>

record_field_get(type, field) ::= <<
pub fn get_<field>(&self) -> <type> {
    return self.<field>;
}
>>

record_field_override(name, field, type, val, parameters) ::= <<
pub fn override_<field>(&self, <field>: <type>) -> <name> {
    return <name>::new(<parameters; separator=", ">);
}
<if(val)>// val = '<val>'<endif>
>>

record_private_variable_prefix() ::= <<
self.
>>

record_equal_predicate(field) ::= <<
self.<field> == other.<field>
>>

record_unequal_predicate(field) ::= <<
self.<field> != other.<field>
>>

record_assignment(identifier) ::= <<
//TODO: record_assignment(<identifier>)
>>

record(struct, parameters) ::= <<
<struct>::new(<parameters; separator=", ">)
>>

constant_initialization(iterationConstruct, identifier, type, val) ::= <<
<iterationConstruct; separator="\n">
self.<identifier> = <val>;
>>

record_field_access(record, field) ::= <<
<record>.get_<field>()
>>

record_access_nested(record, field, isNested) ::= <<
<if(!isNested)><record><else><record>.get_<field>()<endif>
>>

record_access_element(expr, arg, val) ::= <<
<expr>.override_<arg>(<val>)
>>

record_field_to_string(identifier) ::= <<
<identifier>
>>

method() ::= <<
method()
>>

set_declaration(identifier, type, enums) ::= <<
<identifier>: BSet\<<type>\>,
>>

set_initialization(identifier, type, enums) ::= <<
self.<identifier> = BSet::new(vec![<enums; separator=", ">]);
>>

iteration_construct_enumeration(otherIterationConstructs, type, identifier, set, body) ::= <<
<otherIterationConstructs>
for <identifier> in <set>.clone().iter().cloned() {
    <body>
}
>>

iteration_construct_assignment(otherIterationConstructs, type, identifier, set, body) ::= <<
<otherIterationConstructs>
{
    let mut <identifier> = <set>;
    <body>
}
>>

iteration_construct_subset(otherIterationConstructs, type, identifier, set, body) ::= <<
iteration_construct_subset(<otherIterationConstructs>, <type>, <identifier>, <set>, <body>)
>>

iteration_construct_subsetneq(otherIterationConstructs, type, identifier, set, body) ::= <<
iteration_construct_subsetneq(<otherIterationConstructs>, <type>, <identifier>, <set>, <body>)
>>

let_expression_predicate(type, isBool, identifier, body) ::= <<
let mut <identifier>: <type><if(isBool)> = BBoolean::new(false)<endif>;
<body>
>>

let_expression_predicate_body(otherIterationConstructs, identifier, val) ::= <<
<otherIterationConstructs>
<identifier> = <val>;
>>

set_comprehension(type, identifier, isRelation, leftType, rightType, subType, comprehension) ::= <<
let mut <identifier> = <if(isRelation)>BRelation::\<<leftType>, <rightType>\><else>BSet::\<<subType>\><endif>::new(vec![]);
<comprehension>
>>

set_comprehension_predicate(otherIterationConstructs, set, element, emptyPredicate, predicate, isRelation, leftType, rightType, subType) ::= <<
<otherIterationConstructs>
<if(emptyPredicate)>
<set> = <set>._union(&<if(isRelation)>BRelation::\<<leftType>, <rightType>\><else>BSet::\<<subType>\><endif>::new(vec![<element>]));
<else>
if (<predicate>).booleanValue() {
    <set> = <set>._union(&<if(isRelation)>BRelation::\<<leftType>, <rightType>\><else>BSet::\<<subType>\><endif>::new(vec![<element>]));
}
<endif>
>>

lambda(type, identifier, lambda, leftType, rightType) ::= <<
let mut <identifier> = BRelation::\<<leftType>, <rightType>\>::new(vec![]);
<lambda>
>>

lambda_expression(otherIterationConstructs, relation, element, expression, emptyPredicate, predicate, leftType, rightType) ::= <<
<otherIterationConstructs>
<if(emptyPredicate)>
<relation> = <relation>._union(&BRelation::\<<leftType>, <rightType>\>::new(vec![BTuple::new(<element>, <expression>)]));
<else>
if (<predicate>).booleanValue() {
    <relation> = <relation>._union(&BRelation::\<<leftType>, <rightType>\>::new(vec![BTuple::new(<element>, <expression>)]));
}
<endif>
>>

lambda_function(function, parameters, returnType, expression) ::= <<
pub fn <function>(<parameters; separator=", ">) -> <returnType> {
    return <expression>;
}
>>

lambda_function_call(arg1, arg2, fromOtherMachine, otherMachine) ::= <<
<if(fromOtherMachine)><otherMachine>.<endif><arg1>(<arg2; separator=", ">)
>>

quantified_predicate(identifier, forall, predicate) ::= <<
let mut <identifier> = BBoolean::new(<if(forall)>true<else>false<endif>);
<predicate>
>>

quantified_predicate_evaluation(otherIterationConstructs, identifier, emptyPredicate, predicate, forall) ::= <<
<otherIterationConstructs>
<if(emptyPredicate)>
<identifier> = BBoolean::new(<if(forall)>false<else>true<endif>);
break;
<else>
if <if(forall)>!<endif>(<predicate>).booleanValue() {
    <identifier> = BBoolean::new(<if(forall)>false<else>true<endif>);
    break;
}
<endif>
>>

quantified_expression(identifier, identity, setType, evaluation, isInteger) ::= <<
let mut <identifier> = <if(isInteger)>BInteger::new(<identity>);<else>BSet::\<<setType>\>::new(vec![]);<endif>
<evaluation>
>>

quantified_expression_evaluation(otherIterationConstructs, emptyPredicate, predicate, identifier, operation, expression) ::= <<
<otherIterationConstructs>
<if(emptyPredicate)>
<identifier> = <identifier>.<operation>(&<expression>);
<else>
if (<predicate>).booleanValue() {
    <identifier> = <identifier>.<operation>(&<expression>);
}
<endif>
>>

if_expression_predicate(predicate, ifThen, ifElse) ::= <<
(if <predicate>.booleanValue() { <ifThen> } else { <ifElse> })
>>

set_enumeration(leftType, type, rightType, enums, isRelation) ::= <<
<if(isRelation)>BRelation::new<else>BSet::new<endif>(vec![<enums; separator=", ">])
>>

seq_enumeration(type, elements) ::= <<
BRelation::new(vec![<elements; separator=", ">])
>>

enum_call(machine, class, identifier, isCurrentMachine) ::= <<
<if(!isCurrentMachine)><machine>::<endif><class>::<identifier>
>>

set_enum_declaration(name,enums) ::= <<
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum <name> {
    <enums; separator=", \n">
}
impl <name> {
    pub fn equal(&self, other: &<name>) -> BBoolean { BBoolean::new(*self == *other)}
    pub fn unequal(&self, other: &<name>) -> BBoolean { BBoolean::new(*self != *other)}
}
impl BObject for <name> {}
impl Default for <name> {
    fn default() -> Self { <name>::<first(enums)> }
}
impl fmt::Display for <name> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
       match *self {
           <enums:{e | <name>::<e> => write!(f, "<e>"),}; separator="\n">
       }
    }
}
>>

bool() ::= <<
butils::BOOL
>>

include_declaration(type, identifier) ::= <<
<identifier>: <type>::<type>,
>>

include_initialization(type, identifier) ::= <<
self.<identifier> = <type>::<type>::new();
>>

global_declaration(type, identifier) ::= <<
<identifier>: <type>,
>>

constant_declaration(type, identifier) ::= <<
<identifier>: <type>,
>>

values() ::= <<
values()
>>

parallel(loads, others) ::=<<
<loads; separator="\n">
<others; separator="\n">
>>

parallel_load(type, identifier, name) ::= <<
let mut _ld_<name> = <identifier>.clone();
>>

function_call_range_element(expr, leftType, rightType, arg, val) ::= <<
<expr>._override(&BRelation::new(vec![BTuple::new(<arg>,<val>)]))
>>

function_call_nested(expr, arg, isNested) ::= <<
<if(!isNested)><expr><else><expr>.functionCall(&<arg>)<endif>
>>

assignments(assignments) ::= <<
<assignments; separator="\n">
>>

nondeterminism(iterationConstruct, leftType, rightType, identifier, modified_identifier, set, isIdentifierLhs, isRecordAccessLhs, arg) ::= <<
<iterationConstruct; separator="\n">
<if(isIdentifierLhs)><identifier> = <set>.nondeterminism();<elseif(isRecordAccessLhs)><identifier> = <modified_identifier>.override_<arg>(<set>.nondeterminism());<else><identifier> = <modified_identifier>._override(BRelation::new(BTuple::new(<arg>,<set>.nondeterminism()));<endif>
>>

type(type, fromOtherMachine, otherMachine) ::= <<
<if(fromOtherMachine)><otherMachine>::<endif><type>
>>

tuple_type(leftType, rightType) ::=<<
BTuple\<<leftType>, <rightType>\>
>>

set_type(type) ::=<<
BSet\<<type>\>
>>

relation_type(leftType, rightType) ::=<<
BRelation\<<leftType>, <rightType>\>
>>

import_machine(machine) ::= <<
mod <machine>;
>>


interval(arg1, arg2) ::= <<
BSet::\<BInteger>::interval(&<arg1>, &<arg2>)
>>

projection(domainType, rangeType, arg1, arg2, isProjection1) ::= <<
BRelation::<if(isProjection1)>projection1<else>projection2<endif>(&<arg1>, &<arg2>)
>>

projection_tuple(arg, isProjection1) ::= <<
<arg>.<if(isProjection1)>projection1<else>projection2<endif>()
>>

identity(type, arg) ::= <<
BRelation::\<<type>,<type>\>::identity(&<arg>)
>>

cartesian_product(leftType, rightType, arg1, arg2) ::= <<
BRelation::cartesianProduct(&<arg1>, &<arg2>)
>>

tuple_create(leftType, rightType, arg1, arg1IsPrivate, arg2, arg2IsPrivate) ::= <<
BTuple::from_refs(&<arg1>, &<arg2>)
>>

binary(arg1,operator,arg2) ::= <<
<arg1>.<operator>(&<arg2>)
>>

or(arg1, arg2) ::= <<
<arg1>.or(&<arg2>)
>>

and(arg1, arg2) ::= <<
<arg1>.and(&<arg2>)
>>

implies(arg1, arg2) ::= <<
<arg1>.implies(&<arg2>)
>>

equivalent(arg1, arg2) ::= <<
<arg1>.equivalent(&<arg2>)
>>

unary(operator, obj, isOverloadedOperator, args) ::= <<
<obj>.<if(isOverloadedOperator)>unary_<endif><operator>(<if(args)>&<endif><args; separator=", &">)
>>

select(iterationConstruct, predicate, then) ::= <<
<iterationConstruct; separator="\n">
if (<predicate>).booleanValue() {
    <then>
} else {
    panic!("ERROR: called SELECT-function with incompatible parameters!");
}
>>

if(iterationConstruct, predicate, then, else1) ::= <<
<iterationConstruct; separator="\n">
if (<predicate>).booleanValue() {
    <then>
} <else1; separator=" ">
>>

elseif(predicate, then) ::= <<
else if (<predicate>).booleanValue() {
    <then>
}
>>

else(then) ::= <<
else {
    <then>
}
>>

choice(len, then, choice1) ::= <<
let mut rng = thread_rng();
match rng.gen_range(0..<len>) {
    0 => {<then>},
    <choice1; separator=",\n">
}
>>


choice1(counter, then) ::= <<
<counter> => {<then>}
>>

choice2(then) ::= <<
_ => {<then>}
>>

any(body) ::= <<
<body>
>>

any_body(otherIterationConstructs, emptyPredicate, predicate, body) ::= <<
<otherIterationConstructs>
<if(emptyPredicate)>
<body>
<else>
if (<predicate>).booleanValue() {
    <body>
}<endif>
>>

becomes_such_that(loads, body) ::= <<
<loads; separator="\n">
<body>
>>

becomes_such_that_body(otherIterationConstructs, emptyPredicate, predicate, stores) ::= <<
<otherIterationConstructs>
<if(emptyPredicate)>
<stores>
break;
<else>
if (<predicate>).booleanValue() {
    <stores>
    break;
}
<endif>
>>

becomes_such_that_load(type, lhs, rhs) ::= <<
let mut <lhs>: <type> = <rhs>;
>>

becomes_such_that_store(lhs, rhs) ::= <<
<lhs> = <rhs>;
>>

while(iterationConstruct1, iterationConstruct2, predicate, then) ::= <<
<iterationConstruct1; separator="\n">
while (<predicate>).booleanValue() {
    <then>
    <iterationConstruct2; separator="\n">
}
>>

var(locals, body) ::=<<
<locals; separator="\n">
<body>
>>

boolean_val(val) ::= <<
BBoolean::new(<val>)
>>

infinite_predicate(arg, operator) ::= <<
<arg>.<operator>()
>>

relation_predicate(predicates, checkElementOf) ::= <<
<if(checkElementOf)><predicates><else><predicates>.not()<endif>
>>

relation_check_domain(arg, domain) ::= <<
<arg>.checkDomain(<domain>)
>>

relation_check_range(arg, range) ::= <<
<arg>.checkRange(<range>)
>>

relation_total_partial(arg, operator, domain) ::= <<
<arg>.<operator>(<domain>)
>>

relation_function(arg, operator) ::= <<
<arg>.<operator>()
>>

relation_surjection(arg, range) ::= <<
<arg>.isSurjection(<range>)
>>

relation_injection(arg) ::= <<
<arg>.isInjection()
>>

relation_bijection(arg, range) ::=<<
<arg>.isBijection(<range>)
>>

string(string) ::= <<
BString::new(<string>)
>>

operation_call_with_assignment_many_parameters(struct, var, machine, machineInstance, function, args, this, assignments) ::= <<
let mut <var> = <operation_call_without_assignment(machineInstance, function, args, this)>
<assignments; separator="\n">
>>

operation_call_assignment(var, record, field) ::= <<
<var> = <record>.get_<field>();
>>

operation_call_with_assignment_one_parameter(var, machineInstance, function, args, this) ::= <<
<var> = <operation_call_without_assignment(machineInstance, function, args, this)>
>>

operation_call_without_assignment(machineInstance, function, args, this) ::= <<
<if(this)>self.<else>self.<machineInstance>.<endif><function>(<args; separator=",">);
>>

skip() ::= <<
>>

enum-import() ::= <<
enum-import()
>>

mc_info_type(isSet, machine, type) ::= <<
mc_info_type(<isSet>, <machine>, <type>)
>>

machine_equal() ::= <<
machine_equal()
>>

machine_unequal() ::= <<
machine_equal()
>>

machine_equal_predicate() ::= <<
machine_equal_predicate()
>>

machine_unequal_predicate() ::= <<
machine_equal_predicate()
>>

machine_hash() ::= <<
machine_hash()
>>

machine_hash_assignment() ::= <<
machine_hash_assignment()
>>

enum_import() ::= <<
>>
model_check(nextStates, evalState, checkInvariants, printResult, main) ::= <<
<nextStates>

<evalState>

<checkInvariants>

<printResult>

<main>
>>

model_check_next_states(machine, transitionsWithCaching, transitionsWithoutCaching) ::= <<
//model_check_next_states
fn generateNextStates(state: Lift_MC,
                      isCaching: bool,
                      invariant_dependency: &mut HashMap\<String, HashSet\<String>\>,
                      dependent_invariant_m: Arc\<Mutex\<HashMap\<Lift_MC, HashSet\<String>\>\>>,
                      guard_dependency: &mut HashMap\<String, HashSet\<String\>>,
                      dependent_guard_m: Arc\<Mutex\<HashMap\<Lift_MC, HashSet\<String>\>\>>,
                      guardCache: &mut HashMap\<Lift_MC, PersistentHashMap\<&str, bool>\>,
                      parents_m: Arc\<Mutex\<HashMap\<Lift_MC, Lift_MC>\>>,
                      transitions: Arc\<AtomicI64>) -> HashSet\<<machine>\> {
    let mut result = HashSet::<machine>::new();
    if isCaching {
        let mut parentsGuard = guardCache.get(parents_m.lock().unwrap().get(&state).unwrap());
        let mut newCache = if parentsGuard.is_none() { PersistentHashMap::new() } else { parentsGuard.unwrap() };
        let mut dependentGuardsOfState = Option::\<HashSet\<String\>>::None;
        let mut cachedValue = Option::None;
        let mut dependentGuardsBoolean = true;
        <transitionsWithCaching>
        guardCache.put(state, newCache);
    } else {
        <transitionsWithoutCaching>
    }
    return result;
}
>>

model_check_transition(hasParameters, tupleType, transitionIdentifier, evalTransitions, execTransitions, isCaching) ::= <<
//model_check_transition
<if(hasParameters)>
<if(isCaching)>
BSet\<<tupleType>\> <transitionIdentifier>;

dependentGuardsOfState = dependentGuard.get(state);
if(dependentGuardsOfState != null) {
    cachedValue = GET.invoke(parentsGuard, "<evalTransitions>");
    dependentGuardsBoolean = dependentGuardsOfState.contains("<evalTransitions>");
}

if(dependentGuardsOfState == null || dependentGuardsBoolean || parentsGuard == null || cachedValue == null) {
    <transitionIdentifier> = state.<evalTransitions>();
} else {
    <transitionIdentifier> = (BSet\<<tupleType>\>) cachedValue;
}
newCache = (PersistentHashMap) ASSOC.invoke(newCache, "<evalTransitions>", <transitionIdentifier>);
for(<tupleType> param : <transitionIdentifier>) {
    <execTransitions>
}
<else>
BSet\<<tupleType>\> <transitionIdentifier> = state.<evalTransitions>();
for(<tupleType> param : <transitionIdentifier>) {
    <execTransitions>
}
<endif>
<else>
<if(isCaching)>
let mut <transitionIdentifier> = false; //was undefined
dependentGuardsOfState = dependentGuard.get(&state);
if dependentGuardsOfState.is_some() {
    cachedValue = parentsGuard.get("<evalTransitions>");
    dependentGuardsBoolean = dependentGuardsOfState.unwrap().contains("<evalTransitions>");
}

if dependentGuardsOfState.is_none() || dependentGuardsBoolean || parentsGuard.is_none() || cachedValue.is_none() {
    <transitionIdentifier> = state.<evalTransitions>();
} else {
    _trid_1 = cachedValue.unwrap();
}
newCache.insert("<evalTransitions>", <transitionIdentifier>);
if <transitionIdentifier> {
    <execTransitions>
}
<else>
if state.<evalTransitions>() {
    <execTransitions>
}
<endif>
<endif>
>>

model_check_invariants(machine, checkInvariants, invariants) ::= <<
//model_check_invariants
pub fn checkInvariants(state: &<machine>,
                       isCaching: bool,
                       dependent_invariant: HashMap\<<machine>, HashSet\<String>\> ) -> bool {
    if isCaching {
        let mut dependent_invariants_of_state = dependent_invariant.get(&state).unwrap();
        <checkInvariants; separator="\n">
        return true;
    }
    return !(<invariants:{inv | !state.<inv>()}; separator=" || ">);
}
>>

model_check_invariant(invariant) ::= <<
//model_check_invariant
if dependent_invariants_of_state.contains("<invariant>") {
    if !state.<invariant>() {
        return false;
    }
}
>>

model_check_transition_body(machine, operation, hasParameters, readParameters, parameters, isCaching) ::= <<
//model_check_transition_body
<if(hasParameters)>
<readParameters>
<endif>
let mut copiedState = state.clone();
copiedState.<operation>(<parameters; separator=", ">);
<if(isCaching)>
{
    let mut dependent_invariant = dependent_invariant_m.lock().unwrap();
    let mut dependent_guard = dependent_guard_m.lock().unwrap();
    let mut parents = parents_m.lock().unwrap();

    if !dependent_invariant.contains_key(&copiedState) {
        dependent_invariant.put(copiedState.clone(), invariant_dependency.get("<operation>"));
    }
    if !dependent_guard.contains_key(&copiedState) {
        dependent_guard.insert(copiedState.clone(), guardDependency.get("<operation>"));
    }
    if !parents.contains_key(&copiedState) {
        parents.put(copiedState.clone(), state.clone());
    }
}
<endif>
result.add(copiedState);
transitions.getAndIncrement();
>>

model_check_transition_param_assignment(type, param, val, isLhs, oneParameter) ::= <<
//model_check_transition_param_assignment
<if(isLhs)>
<type> <param> = <val>.projection1();
<else>
<if(oneParameter)>
<type> <param> = <val>;
<else>
<type> <param> = <val>.projection2();
<endif>
<endif>
>>

model_check_evaluate_state(machine, variables) ::= <<
//model_check_evaluate_state
>>

model_check_evaluate_variable(getter) ::= <<
//model_check_evaluate_variable
state.put("<getter>", machine.<getter>());
>>

model_check_print() ::= <<
//model_check_print
fn printResult(states: i32, transitions: i32, deadlock_detected: bool, invariant_violated: bool) {
    if deadlock_detected { println!("DEADLOCK DETECTED"); }
    if invariant_violated { println!("INVARIANT VIOLATED"); }
    if !deadlock_detected && !invariant_violated { println!("MODEL CHECKING SUCCESSFUL"); }
    println!("Number of States: {}", states);
    println!("Number of Transitions: {}", transitions);
}
>>

model_check_init_static(map, keyy, entries) ::= <<
//model_check_init_static
<map>.insert("<keyy>", HashSet::String::from(<entries:{entry | "<entry>"}; separator=", ">));
>>

model_check_main(machine, invariants, invariantDependency, guardDependency) ::= <<
//model_check_main
fn next(collection_m: Arc\<Mutex\<LinkedList\<Lift_MC>\>>, mc_type: MC_TYPE) -> Lift_MC {
    let mut collection = collection_m.lock().unwrap();
    return match mc_type {
            MC_TYPE::BFS   => collection.pop_front().unwrap(),
            MC_TYPE::DFS   => collection.pop_back().unwrap(),
            MC_TYPE::MIXED => if collection.len() % 2 == 0 { collection.pop_front().unwrap() } else { collection.pop_back().unwrap() }
        };
}

fn model_check_single_threaded(mc_type: MC_TYPE, is_caching: bool) {
    //Object lock = new Object();
    //Object guardLock = new Object();

    let mut machine = <machine>::new();


    let mut invariant_violated = AtomicBool::new(false);
    let mut deadlock_detected = AtomicBool::new(false);
    let mut stop_threads = AtomicBool::new(false);;

    if <invariants:{inv | !machine.<inv>()}; separator=" || "> {
        invariant_violated.store(true, Ordering::Release);
    }

    let mut states = HashSet::\<<machine>\>::new();
    states.add(machine.clone());
    let mut number_states = AtomicI64::new(1);

    let mut collection_m = Arc::new(Mutex::new(LinkedList::<machine>::new()));
    collection_m.lock().unwrap().push_back(machine.copy());

    let mut invariantDependency = HashMap::\<&str, HashSet\<String>\>::new();
    let mut guardDependency = HashMap::\<&str, HashSet\<String>\>::new();
    let mut dependent_invariant_m = Arc::new(Mutex::new(HashMap::\<<machine>, HashSet\<String>\>::new()));
    let mut dependent_guard_m = Arc::new(Mutex::new(HashMap::\<<machine>, HashSet\<String>\>::new()));
    let mut guard_cache = HashMap::\<<machine>, PersistentHashMap\<&str, bool\>>::new();
    let mut parents = Arc::new(Mutex::new(HashMap::\<<machine>, <machine>\>::new()));

    if is_caching {
        <invariantDependency; separator="\n">
        <guardDependency; separator="\n">
        dependent_invariant.insert(machine.clone(), HashSet::new());
        parents.remove(&machine);
    }

    let mut transitions = Arc::new(AtomicI64::new(0));

    while !stop_threads.fetch_or(collection_m.lock().unwrap().is_empty(), Ordering::Acquire) {
        let mut state = Self::next(Arc::clone(&collection_m), mc_type);

        let mut next_states = Self::generateNextStates(state, is_caching, &mut invariantDependency, Arc::clone(&dependent_invariant_m), &mut guardDependency, Arc::clone(&dependent_guard_m), &mut guard_cache, Arc::clone(&parents), Arc::clone(&transitions));

        next_states.iter().for_each(|next_state| {
            if !states.contains(next_state) {
                let cnum_states = number_states.fetch_add(1, Ordering::AcqRel) + 1;
                states.add(next_state.clone());
                collection.add(next_state.clone());
                if cnum_states % 50000 == 0 {
                    println!("VISITED STATES: {}", cnum_states);
                    println!("EVALUATED TRANSITIONS: {}", transitions.get());
                    println!("-------------------");
                }
            }
        });

        if next_states.is_empty() {
            deadlock_detected.store(true, Ordering::Release);
            stop_threads.store(true, Ordering::Release);
        }

        if !Self::checkInvariants(&state, is_caching, dependentInvariant) {
            invariant_violated.store(true, Ordering::Release);
            stop_threads.store(true, Ordering::Release);
        }

    }
    printResult(number_states.get(), transitions.get(), deadlockDetected.get(), invariantViolated.get());
}

/*
private static void modelCheckMultiThreaded(Type type, int threads, boolean isCaching) {
    Object lock = new Object();
    Object guardLock = new Object();
    Object waitLock = new Object();
    ThreadPoolExecutor threadPool = (ThreadPoolExecutor) Executors.newFixedThreadPool(threads);

    <machine> machine = new <machine>();


    AtomicBoolean invariantViolated = new AtomicBoolean(false);
    AtomicBoolean deadlockDetected = new AtomicBoolean(false);
    AtomicBoolean stopThreads = new AtomicBoolean(false);
    AtomicInteger possibleQueueChanges = new AtomicInteger(0);

    if(<invariants:{inv | !machine.<inv>()}; separator=" || ">) {
        invariantViolated.set(true);
    }

    Set\<<machine>\> states = new HashSet\<>();
    states.add(machine);
    AtomicInteger number_states = new AtomicInteger(1);

    LinkedList\<<machine>\> collection = new LinkedList\<>();
    collection.add(machine);

    Map\<String, Set\<String>\> invariant_dependency = new HashMap\<>();
    Map\<String, Set\<String>\> guard_dependency = new HashMap\<>();
    Map\<<machine>, Set\<String>\> dependentInvariant = new HashMap\<>();
    Map\<<machine>, Set\<String>\> dependentGuard = new HashMap\<>();
    Map\<<machine>, PersistentHashMap> guardCache = new HashMap\<>();
    Map\<<machine>, <machine>\> parents = new HashMap\<>();
    if(isCaching) {
        <invariantDependency; separator="\n">
        <guardDependency; separator="\n">
        dependentInvariant.put(machine, new HashSet\<>());
        parents.put(machine, null);
    }

    AtomicInteger transitions = new AtomicInteger(0);

    while(!collection.isEmpty() && !stopThreads.get()) {
        possibleQueueChanges.incrementAndGet();
        <machine> state = next(collection, lock, type);
        Runnable task = () -> {
            Set\<<machine>\> nextStates = generateNextStates(guardLock, state, isCaching, invariant_dependency, dependentInvariant, guard_dependency, dependentGuard, guardCache, parents, transitions);

            nextStates.forEach(nextState -> {
                synchronized(lock) {
                    if(!states.contains(nextState)) {
                        number_states.getAndIncrement();
                        states.add(nextState);
                        collection.add(nextState);
                        if(number_states.get() % 50000 == 0) {
                            System.out.println("VISITED STATES: " + number_states.get());
                            System.out.println("EVALUATED TRANSITIONS: " + transitions.get());
                            System.out.println("-------------------");
                        }
                    }
                }
            });

            synchronized (lock) {
                int running = possibleQueueChanges.decrementAndGet();
                if (!collection.isEmpty() || running == 0) {
                    synchronized (waitLock) {
                        waitLock.notify();
                    }
                }
            }

            if(nextStates.isEmpty()) {
                deadlockDetected.set(true);
                stopThreads.set(true);
            }

            if(!checkInvariants(state, isCaching, dependentInvariant)) {
                invariantViolated.set(true);
                stopThreads.set(true);
            }


        };
        threadPool.submit(task);
        synchronized(waitLock) {
            if (collection.isEmpty() && possibleQueueChanges.get() > 0) {
                try {
                    waitLock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }

    }
    threadPool.shutdown();
    try {
        threadPool.awaitTermination(5, TimeUnit.SECONDS);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    printResult(number_states.get(), transitions.get(), deadlockDetected.get(), invariantViolated.get());
}
*/

fn main() {
    let args: Vec\<String> = env::args().collect();
    if args.len() != 3 { panic!("Number of arguments errorneous"); }

    let threads = args.get(2).unwrap().parse::\<i32>().unwrap();
    if threads \<= 0 { panic!("Input for number of threads is wrong."); }

    let is_caching = args.get(3).unwrap().parse::\<bool>().unwrap();
    let mc_type = match args.get(1).unwrap().as_str() {
        "mixed" => MC_TYPE::MIXED,
        "bf" => MC_TYPE::BFS,
        "df" => MC_TYPE::DFS,
        _    => panic!("Input for strategy is wrong.")
    };

    if threads == 1 {
        model_check_single_threaded(mc_type, isCaching);
    } else {
        //modelCheckMultiThreaded(mc_type, threads, isCaching);
    }
}
>>

copy_constructor(machine, parameters, assignments) ::= <<
public <machine>(<parameters; separator=", ">) {
    //copy_constructor
    <assignments; separator="\n">
}
>>

copy_assignment(variable) ::= <<
//copy_assignment
this.<variable> = <variable>;
>>

pre_assert(isModelChecking, isTopLevel, iterationConstruct, predicate, then) ::= <<
//pre_assert
<if(isModelChecking && !isTopLevel)>
<iterationConstruct; separator="\n">
if((<predicate>).booleanValue()) {
    <then>
} else {
    throw new PreconditionOrAssertionViolation("Precondition or Assertion Error occured.");
}
<else>
<then>
<endif>
>>

transition(noParameters, noPredicate, identifier, subType, operationName, predicate, hasCondition, conditionalPredicate, combination) ::= <<
pub fn _tr_<operationName>(&self) -> <if(noParameters)>bool<else>BSet\<<subType>\><endif> {
    //transition
    <if(noParameters)>
    <if(noPredicate)>
    return true;
    <else>
    return <predicate>.booleanValue();
    <endif>
    <else>
    let mut <identifier>: BSet\<<subType>\> = BSet::new();
    <if(hasCondition)>
    if <conditionalPredicate>.booleanValue() {
        <combination>
    }
    <else>
    <combination>
    <endif>
    return <identifier>;
    <endif>
}
>>

invariant(invariantFunction, iterationConstruct, predicate) ::= <<
pub fn <invariantFunction>(&self) -> bool {
    //invariant
    <iterationConstruct; separator="\n">
    return <predicate>.booleanValue();
}
>>

copy(machine, parameters) ::= <<
>>

machine_string(variables) ::= <<
@Override
public String toString() {
    //machine_string
    <if(variables)>
    return String.join("\n", <variables:{var | "<var>: " + (this.<var>()).toString()}; separator=", ">);
    <else>
    return "";
    <endif>
}
>>
keywords() ::= <<
as, break, const, continue, crate, else, enum, extern, false, fn, for, if, impl, in, let, loop, match, mod, move, mut, pub, ref, return, self, Self, static, struct, super, trait, true, type, unsafe, use, where, while, async, await, dyn, abstract, become, box, do, final, macro, override, priv, typeof, unsized, virtual, yield, try, union, dyn, min, max
>>


machine(imports, includedMachines, machine, structs, constants_declarations, includes, enums, sets, declarations, initialization, operations, addition, useBigInteger, getters, lambdaFunctions) ::= <<
#![ allow( dead_code, unused_imports, unused_mut ) ]

use std::fmt;
<imports; separator="\n">
<if(useBigInteger)>//TODO BigInt<endif>
<includedMachines; separator="\n">
<if(includes)><includes; separator="\n"><endif>

<structs; separator="\n\n">

<enums; separator="\n\n">

#[derive(Default, Debug)]
pub struct <machine> {
    <if(declarations)><declarations; separator="\n"><endif>
    <sets; separator="\n">
}

impl <machine> {
    #![allow(non_snake_case)]
    <initialization>
    <if(getters)><\n><getters; separator="\n\n"><endif>
    <if(operations)><\n><operations; separator="\n\n">
    <endif>
}

<lambdaFunctions; separator="\n\n">
<addition>
>>

import_type(type, useBigInteger) ::= <<
<if(useBigInteger)>//TODO: import type with BigInteger<endif>
use btypes::<type; format="lower">::<type>;
>>

initialization(machine, properties, values, body, sets) ::= <<
<properties; separator="\n">

pub fn new() -> <machine> {
<if(values)>    //values: '<values>'<endif>
    let mut m: <machine> = Default::default();
    m.init();
    return m;
}
fn init(&mut self) {
    <body>
    <sets; separator="\n">
}
>>

assignment(leftType, rightType, iterationConstruct, identifier, modified_identifier, val, isIdentifierLhs, isRecordAccessLhs, arg) ::= <<
<iterationConstruct; separator="|">
<if(!isIdentifierLhs)>//TODO: assignment: identifier is not Lhs!<endif>
<if(isRecordAccessLhs)>//TODO: assignment: RecordAccessLhs!<endif>
<if(arg)>//TODO: assignment: arg<endif>
<identifier> = <val>;
>>

identifier(machine, identifier, isReturn, isPrivate, rhsOnLhs, fromOtherMachine, otherMachine, isConstant) ::= <<
<if(rhsOnLhs)>//TODO: identifier rhsOnLhs<endif>
<if(fromOtherMachine)>//TODO: identifier from Other Machine <otherMachine><endif>
<if(isPrivate)>self.<elseif(isConstant)><machine>::<endif><identifier>
>>

getter(returnType, isConstant, machine, variable) ::= <<
pub fn get_<variable>(&self) -> <returnType> {
    return <if(isConstant)><machine>::<else>self.<endif><variable>.clone();
}
>>

operation(returnType, operationName, parameters, locals, body, return) ::= <<
pub fn <operationName>(&mut self<if(parameters)>, <endif><parameters; separator=", ">) -> <returnType> {
    <locals; separator="|">
    <body>
    <return>
}
>>

parameter(type, identifier) ::= <<
mut <identifier>: <type>
>>

return(identifier) ::= <<
return <identifier>;
>>

no_return() ::=<<
>>

void() ::= <<
()
>>

local_declaration(type, identifier) ::= <<
<declaration(type, identifier)>
>>

declaration(type, identifier) ::= <<
let mut <identifier>: <type>;
>>

number(number, useBigInteger) ::= <<
<if(useBigInteger)>//TODO: BigInteger<endif>
BInteger::new(<number>)
>>

struct(name, declarations, parameters, initializations, functions, assignments, equalPredicates, unequalPredicates, values, fields) ::= <<
#[derive(Default, Debug)]
pub struct <name> {
    <if(declarations)><declarations; separator="\n"><endif>
}

impl BStruct for <name> {}

impl <name> {
    pub fn new(<parameters; separator=", ">) -> <name> {
        let mut m: <name> = Default::default();
        <initializations>
        return m;
    }

    <functions; separator="\n\n">

    pub fn equal(&self, other: &<name>) -> BBoolean {
        return BBoolean::new(<equalPredicates; separator=" && ">);
    }

    pub fn unequal(&self, other: &<name>) -> BBoolean {
        return BBoolean::new(<unequalPredicates; separator=" || ">);
    }

    <if(assignments)><assignments><endif>
}
>>

record_field_initialization(identifier) ::= <<
m.<identifier> = <identifier>;
>>

record_field_get(type, field) ::= <<
pub fn get_<field>(&self) -> <type> {
    return self.<field>;
}
>>

record_field_override(name, field, type, val, parameters) ::= <<
pub fn override_<field>(&self, <field>: <type>) -> <name> {
    return <name>::new(<parameters; separator=", ">);
}
<if(val)>// val = '<val>'<endif>
>>

record_private_variable_prefix() ::= <<
self.
>>

record_equal_predicate(field) ::= <<
self.<field> == other.<field>
>>

record_unequal_predicate(field) ::= <<
self.<field> != other.<field>
>>

record_assignment(identifier) ::= <<
//TODO: record_assignment(<identifier>)
>>

record(struct, parameters) ::= <<
<struct>::new(<parameters; separator=", ">)
>>

constant_initialization(iterationConstruct, identifier, type, val) ::= <<
<iterationConstruct; separator="\n">
const <identifier>: <type> = <val>;
>>

record_field_access(record, field) ::= <<
record_field_access(<record>, <field>)
>>

record_access_nested(record, field, isNested) ::= <<
record_access_nested(<record>, <field>. <isNested>)
>>

record_access_element(expr, arg, val) ::= <<
record_access_element(<expr>, <arg>, <val>)
>>

record_field_to_string(identifier) ::= <<
record_field_to_string(<identifier>)
>>

method() ::= <<
method()
>>

set_declaration(identifier, type, enums) ::= <<
<identifier>: BSet\<<type>\>,
>>

set_initialization(identifier, type, enums) ::= <<
self.<identifier> = BSet::new(vec![<enums; separator=", ">]);
>>

iteration_construct_enumeration(otherIterationConstructs, type, identifier, set, body) ::= <<
iteration_construct_enumeration<otherIterationConstructs>, <type>, <identifier>, <set>, <body>)
>>

iteration_construct_assignment(otherIterationConstructs, type, identifier, set, body) ::= <<
iteration_construct_assignment(<otherIterationConstructs>, <type>, <identifier>, <set>, <body>)
>>

iteration_construct_subset(otherIterationConstructs, type, identifier, set, body) ::= <<
iteration_construct_subset(<otherIterationConstructs>, <type>, <identifier>, <set>, <body>)
>>

iteration_construct_subsetneq(otherIterationConstructs, type, identifier, set, body) ::= <<
iteration_construct_subsetneq(<otherIterationConstructs>, <type>, <identifier>, <set>, <body>)
>>

let_expression_predicate(type, identifier, body) ::= <<
let_expression_predicate(<type>, <identifier>, <body>)
>>

let_expression_predicate_body(otherIterationConstructs, identifier, val) ::= <<
let_expression_predicate_body(<otherIterationConstructs>, <identifier>, <val>)
>>

set_comprehension(type, identifier, comprehension) ::= <<
//TODO: set_comprehension(<type>, <identifier>, <comprehension>);
>>

set_comprehension_predicate(otherIterationConstructs, set, type, element, emptyPredicate, predicate, isRelation) ::= <<
//TODO: set_comprehension_predicate(<otherIterationConstructs>, <set>, <type>, <element>, <emptyPredicate>, <predicate>, <isRelation>)
>>

lambda(type, identifier, lambda) ::= <<
//TODO: lambda(<type>, <identifier>, <lambda>)
>>

lambda_expression(otherIterationConstructs, relation, leftType, rightType, element, expression, emptyPredicate, predicate) ::= <<
//TODO: lambda_expression(<otherIterationConstructs>, <relation>, <leftType>, <rightType>, <element>, <expression>, <emptyPredicate>, <predicate>)
>>

lambda_function(function, parameters, returnType, expression) ::= <<
//TODO: lambda_function(<function>, <parameters>, <returnType>, <expression>)
}
>>

lambda_function_call(arg1, arg2, fromOtherMachine, otherMachine) ::= <<
//TODO: lambda_function_call(<arg1>, <arg2>, <fromOtherMachine>, <otherMachine>)
>>

quantified_predicate(identifier, forall, predicate) ::= <<
//TODO: quantified_predicate(<identifier>, <forall>, <predicate>)
>>

quantified_predicate_evaluation(otherIterationConstructs, identifier, emptyPredicate, predicate, forall) ::= <<
//TODO: quantified_predicate_evaluation(<otherIterationConstructs>, <identifier>, <emptyPredicate>, <predicate>, <forall>)
>>

quantified_expression(identifier, identity, setType, evaluation, isInteger) ::= <<
quantified_expression(<identifier>, <identity>, <setType>, <evaluation>, <isInteger>)
>>

quantified_expression_evaluation(otherIterationConstructs, emptyPredicate, predicate, identifier, operation, expression) ::= <<
quantified_expression_evaluation(<otherIterationConstructs>, <emptyPredicate>, <predicate>, <identifier>, <operation>, <expression>)
>>

if_expression_predicate(predicate, ifThen, ifElse) ::= <<
if_expression_predicate(<predicate>, <ifThen>, <ifElse>)
>>

set_enumeration(leftType, type, rightType, enums, isRelation) ::= <<
<if(isRelation)>BRelation::new<else>BSet::new<endif>(vec![<enums; separator=", ">])
>>

seq_enumeration(type, elements) ::= <<
seq_enumeration(<type>, (<elements; separator="|">)
>>

enum_call(machine, class, identifier, isCurrentMachine) ::= <<
<if(!isCurrentMachine)>//TODO: enum_call to not current machine<endif>
<class>::<identifier>
>>

set_enum_declaration(name,enums) ::= <<
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub enum <name> {
    <enums; separator=", \n">
}
impl <name> {
    pub fn equal(&self, other: <name>) -> BBoolean { BBoolean::new(*self == other)}
}
impl BObject for <name> {}
impl Default for <name> {
    fn default() -> Self { <name>::<first(enums)> }
}
impl fmt::Display for <name> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
       match *self {
           <enums:{e | <name>::<e> => write!(f, "<e>"),}; separator="\n">
       }
    }
}
>>

bool() ::= <<
bool()
>>

include_declaration(type, identifier) ::= <<
include_declaration(<type>, <identifier>)
>>

global_declaration(type, identifier) ::= <<
<identifier>: <type>,
>>

constant_declaration(type, identifier) ::= <<
constant_declaration(<type>, <identifier>)
>>

values() ::= <<
values()
>>

parallel(loads, others) ::=<<
<loads; separator="\n">
<others; separator="\n">
>>

parallel_load(type, identifier) ::= <<
parallel_load(<type>, <identifier>)
>>

function_call_range_element(expr, leftType, rightType, arg, val) ::= <<
function_call_range_element(<expr>, <leftType>, <rightType>, <arg>, <val>)
>>

function_call_nested(expr, arg, isNested) ::= <<
function_call_nested(<expr>, <arg>, <isNested>)
>>

assignments(assignments) ::= <<
assignments(<assignments; separator="|">)
>>

nondeterminism(iterationConstruct, leftType, rightType, identifier, modified_identifier, set, isIdentifierLhs, isRecordAccessLhs, arg) ::= <<
nondeterminism(<iterationConstruct; separator="|">, <leftType>, <rightType>, <identifier>, <modified_identifier>, <set>, <isIdentifierLhs>, <isRecordAccessLhs>, <arg>)
>>

type(type, fromOtherMachine, otherMachine) ::= <<
<if(fromOtherMachine)>//TODO: type with fromOtherMachine=true<endif>
<type>
>>

tuple_type(leftType, rightType) ::=<<
tuple_type(<leftType>, <rightType>)
>>

set_type(type) ::=<<
BSet\<<type>\>
>>

relation_type(leftType, rightType) ::=<<
BRelation\<<leftType>, <rightType>\>
>>

import_machine(machine) ::= <<
import_machine(<machine>)
>>


interval(arg1, arg2) ::= <<
interval(<arg1>, <arg2>)
>>

projection(domainType, rangeType, arg1, arg2, isProjection1) ::= <<
projection(<domainType>, <rangeType>, <arg1>, <arg2>, <isProjection1>)
>>

projection_tuple(arg, isProjection1) ::= <<
projection_tuple(<arg>, <isProjection1>)
>>

identity(type, arg) ::= <<
identity(<type>, <arg>)
>>

cartesian_product(leftType, rightType, arg1, arg2) ::= <<
cartesian_product(<leftType>, <rightType>, <arg1>, <arg2>)
>>

tuple_create(leftType, rightType, arg1, arg2) ::= <<
BTuple::new(vec![<arg1>, <arg2>])
>>

binary(arg1,operator,arg2) ::= <<
<arg1>.<operator>(&<arg2>)
>>

or(arg1, arg2) ::= <<
<arg1>.or(&<arg2>)
>>

and(arg1, arg2) ::= <<
<arg1>.and(&<arg2>)
>>

implies(arg1, arg2) ::= <<
<arg1>.implies(&<arg2>)
>>

equivalent(arg1, arg2) ::= <<
<arg1>.equivalent(&<arg2>)
>>

unary(operator, obj, args) ::= <<
<obj>.<operator>(<args; separator=", ">)
>>

select(iterationConstruct, predicate, then) ::= <<
<iterationConstruct; separator="\n">
if (<predicate>).booleanValue() {
    <then>
}
>>

if(iterationConstruct, predicate, then, else1) ::= <<
<iterationConstruct; separator="\n">
if (<predicate>).booleanValue() {
    <then>
} <else1; separator=" ">
>>

elseif(predicate, then) ::= <<
else if (<predicate>).booleanValue() {
    <then>
}
>>

else(then) ::= <<
else {
    <then>
}
>>

choice(len, then, choice1) ::= <<
choice(<len>, <then>, <choice1; separator="|">)
>>


choice1(counter, then) ::= <<
choice1(<counter>, <then>)
}
>>

choice2(then) ::= <<
choice2(<counter>, <then>)
>>

any(body) ::= <<
any(<body>)
>>

any_body(otherIterationConstructs, emptyPredicate, predicate, body) ::= <<
any_body(<otherIterationConstructs>, <emptyPredicate>, <predicate>, <body>)
>>

becomes_such_that(loads, body) ::= <<
becomes_such_that(<loads; separator="|">, <body>)
>>

becomes_such_that_body(otherIterationConstructs, emptyPredicate, predicate, stores) ::= <<
becomes_such_that_body(<otherIterationConstructs>, <emptyPredicate>, <predicate>, <stores>)
>>

becomes_such_that_load(type, lhs, rhs) ::= <<
becomes_such_that_load(<type>, <lhs>, <rhs>)
>>

becomes_such_that_store(lhs, rhs) ::= <<
becomes_such_that_store(<lhs>, <rhs>)
>>

while(iterationConstruct1, iterationConstruct2, predicate, then) ::= <<
//TODO: while(<iterationConstruct1; separator="|">, <iterationConstruct2; separator="|">, <predicate>, <then>)
>>

var(locals, body) ::=<<
var(<locals; separator="|">, <body>)
>>

boolean_val(val) ::= <<
BBoolean::new(<val>)
>>

infinite_predicate(arg, operator) ::= <<
infinite_predicate(<arg>, <operator>)
>>

relation_predicate(predicates, checkElementOf) ::= <<
relation_predicate(<predicates>, <checkElementOf>)
>>

relation_check_domain(arg, domain) ::= <<
relation_check_domain(<arg>, <domain>)
>>

relation_check_range(arg, range) ::= <<
relation_check_range(<arg>, <range>)
>>

relation_total_partial(arg, operator, domain) ::= <<
relation_total_partial(<arg>, <operator>, <domain>)
>>

relation_function(arg, operator) ::= <<
relation_function(<arg>, <operator>)
>>

relation_surjection(arg, range) ::= <<
relation_surjection(<arg>, <range>)
>>

relation_injection(arg) ::= <<
relation_injection(<arg>)
>>

relation_bijection(arg, range) ::=<<
relation_bijection(<arg>, <range>)
>>

string(string) ::= <<
//TODO: string(<string>)
>>

operation_call_with_assignment_many_parameters(struct, var, machine, machineInstance, function, args, this, assignments) ::= <<
operation_call_with_assignment_many_parameters(<struct>, <var>, <machine>, <machineInstance>, <function>, <args>, <this>, <assignments; separator="|">)
>>

operation_call_assignment(var, record, field) ::= <<
operation_call_assignment(<var>, <record>, <field>)
>>

operation_call_with_assignment_one_parameter(var, machineInstance, function, args, this) ::= <<
operation_call_with_assignment_one_parameter(<var>, <machineInstance>, <function>, <args>, <this>)
>>

operation_call_without_assignment(machineInstance, function, args, this) ::= <<
operation_call_without_assignment(<machineInstance>, <function>, <args; separator="|">, <this>)
>>

skip() ::= <<
>>

enum-import() ::= <<
enum-import()
>>

mc_info_type(isSet, machine, type) ::= <<
mc_info_type(<isSet>, <machine>, <type>)
>>